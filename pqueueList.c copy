/* * File:   queueList.c * Author: Suzanne Aldrich * ------------------ * This file implements the priority queue abstraction as a sorted * linked list of values. */#include "pqueue.h"typedef struct cellT {	int value;	struct cellT *link;} cellT;struct pqueueCDT{	cellT *start;};/* Public functions */pqueueADT NewPriorityQueue(void){    pqueueADT queue = New(pqueueADT);        queue->start = NULL;    return queue;}void FreeQueue(pqueueADT queue){    cellT *ptra, *ptrb;           ptra = queue->start;    while (ptra != NULL)  {    	ptrb = ptra->link;    	FreeBlock(ptra);    	ptra = ptrb;    }    FreeBlock(queue);	}bool IsEmpty(pqueueADT queue){    return (queue->start == NULL);  }bool IsFull(pqueueADT queue){    return FALSE;  }void Insert(pqueueADT queue, int newValue){ 	cellT *prev = NULL, *next = queue->start, *newcell = GetBlock(sizeof(cellT));           	 while (next != NULL && next->value > newValue) { 		prev = next;	 	next = next->link;	 }	 if (prev != NULL) {	 	prev->link = newcell;	 } else {	 	queue->start = newcell;	 } 	 newcell->value = newValue;	 newcell->link = next; }int ExtractMax(pqueueADT queue){	if (queue->start == NULL) {		Error("Tried to extract max from an empty queue!");		return NOT_FOUND;	}	return Delete(queue, queue->start->value);}		int Search(pqueueADT queue, int key){	cellT *cp;		for (cp = queue->start; cp != NULL; cp = cp->link) {		if (cp->value == key)  {			return key;		}	}	return NOT_FOUND;}int Delete(pqueueADT queue, int elem){		cellT *current = queue->start, *prev = NULL;	repeat {		if (current == NULL)			return NOT_FOUND;		if (current->value == elem)			break;		prev = current;		current = current->link;	}	if (prev == NULL) {		queue->start = current->link;	} else {		prev->link = current->link;		}	FreeBlock(current);	return elem;}