/* * File: queueArray.c * ---------------------------- * This file implements the priority queue abstraction as a fixed-sized * array of integers stored in no particular order.    */#include "pqueue.h"#define MAX_ELEMENTS 10000	// fixed size of array/* * Type: pqueueCDT * -------------------- * This type defines the underlying concrete representation for a * priority queue ADT.  These details are not relevant to and therefore * not exported to the client.  In this implementation, the * underlying structure is a fixed-sized array of integers. */struct pqueueCDT{	int entries[MAX_ELEMENTS];	int numEntries;				// effective size of the above array};static int IndexOfMax(int array[], int size);static int FindIndexOfElement(int array[], int size, int key);static int DeleteElementAtIndex(pqueueADT queue, int index);/* Public functions */pqueueADT NewPriorityQueue(void){    pqueueADT queue;    queue = New(pqueueADT);    queue->numEntries = 0;    return queue;}void FreeQueue(pqueueADT queue){    FreeBlock(queue);	// no other embedded pointers to free}bool IsEmpty(pqueueADT queue){    return (queue->numEntries == 0);  }bool IsFull(pqueueADT queue){    return (queue->numEntries == MAX_ELEMENTS);  }/* Function: Insert * ---------------- * Since we're keeping the array in no particular order, we just append this * new element to the end of the array.  It's the easiest and fastest thing * to do, so why not? */void Insert(pqueueADT queue, int newValue){	if (queue->numEntries == MAX_ELEMENTS)	// no more space to add elements!		Error("Tried to insert into a priority queue which is full!");	queue->entries[queue->numEntries++] = newValue;}/* Function: ExtractMax * -------------------- * Since we're keeping the array in no particular order, we have to search to * find the largest element.  We then use our helper function to extract that * element from the queue, close up the gap, and return its value. */int ExtractMax(pqueueADT queue){	if (queue->numEntries == 0)		Error("Tried to extract max from an empty queue!");			return DeleteElementAtIndex(queue, IndexOfMax(queue->entries, queue->numEntries));}		/* Function: Search * ---------------- * Since we're keeping the array in no particular order, we have to search to * find the element.   */int Search(pqueueADT queue, int key){	int index;		index = FindIndexOfElement(queue->entries, queue->numEntries, key);	if (index != NOT_FOUND) 		return queue->entries[index];	else 		return NOT_FOUND;}/* Function: Delete * -------------------- * Since we're keeping the array in no particular order, we have to search to * find the element.  We use our helper to close up the gap left behind if * we do remove an element and return its value, otherwise we just return * NOT_FOUND and the queue contents are unchanged. */int Delete(pqueueADT queue, int elem){	int index;		index = FindIndexOfElement(queue->entries, queue->numEntries, elem);	if (index != NOT_FOUND)		return DeleteElementAtIndex(queue, index);	else		return NOT_FOUND;}/* Private Functions *//* * Function: IndexOfMax * -------------------- * Searches the array to find the index of the largest element using * a simple linear scan. */static int IndexOfMax(int array[], int size){	int i, maxIndex;		maxIndex = 0;	// assume first element is largest until proven otherwise	for (i = 1; i < size; i++)		if (array[i] > array[maxIndex])			maxIndex = i;	return maxIndex;}/* * Function: FindIndexOfElement * ---------------------------- * Linear search down the array to find the index of the given element or * NOT_FOUND if no such entry exists. */static int FindIndexOfElement(int array[], int size, int key ){	int i;		for (i = 0; i < size; i++)		if (array[i] == key)			return i;	return NOT_FOUND;}/* * Function: DeleteElementAtIndex * ------------------------------- * To remove a value from the middle, we move the last elem in the array * into the slot vacated by the deleted elem and decrement our number of entries. * There's no reason to shuffle the array elements down to cover the gap * since that would be expensive and pointless.  The value removed is * the one returned. */static int DeleteElementAtIndex(pqueueADT queue, int index){	int value;		value = queue->entries[index]; 	// save value to return	queue->entries[index] = queue->entries[--queue->numEntries]; // swap last into this slot	return value;}